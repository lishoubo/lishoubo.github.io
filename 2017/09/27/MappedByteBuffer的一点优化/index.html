<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="中间件, 高可用, 架构, 读书"><title>MappedByteBuffer的一点优化 | Lost</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?5c504f7ca80d4d57db5434656761512d";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MappedByteBuffer的一点优化</h1><a id="logo" href="/.">Lost</a><p class="description">朽骨暗夜，侯多时，你已徘徊多远?</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/favorite/"><i class="fa fa-star"> 收藏</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://lishoubo.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/思考/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/高可用/" style="font-size: 15px;">高可用</a> <a href="/tags/性能/" style="font-size: 15px;">性能</a> <a href="/tags/文件/" style="font-size: 15px;">文件</a> <a href="/tags/PageCache/" style="font-size: 15px;">PageCache</a> <a href="/tags/实时处理/" style="font-size: 15px;">实时处理</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/flink/" style="font-size: 15px;">flink</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/问题排查/" style="font-size: 15px;">问题排查</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/压测/" style="font-size: 15px;">压测</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/科幻/" style="font-size: 15px;">科幻</a> <a href="/tags/心理/" style="font-size: 15px;">心理</a> <a href="/tags/一般/" style="font-size: 15px;">一般</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/推荐/" style="font-size: 15px;">推荐</a> <a href="/tags/小说/" style="font-size: 15px;">小说</a> <a href="/tags/历史/" style="font-size: 15px;">历史</a> <a href="/tags/人类/" style="font-size: 15px;">人类</a> <a href="/tags/思维/" style="font-size: 15px;">思维</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/15/全链路压测的大概思路/">全链路压测的大概思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/02/一个加锁粒度引起的问题/">一个加锁粒度引起的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/03/关于Netty的OutOfDirectMemoryError/">关于Netty的OutOfDirectMemoryError</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/23/读书-活着/">读书-活着</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/23/两阶段加锁/">两阶段加锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/MappedByteBuffer的一点优化/">MappedByteBuffer的一点优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/读书-银河帝国基地七部曲/">读书-银河帝国基地七部曲</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/20/flink实时分析的几点总结/">flink实时分析的几点总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/31/流处理中反压问题/">大流量下的反压问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/排查CPU偏高引起的一点思考/">排查CPU偏高引起的一点思考</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://jm.taobao.org" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://martin.kleppmann.com/" title="分布式专家Martin的博客" target="_blank">分布式专家Martin的博客</a><ul></ul><a href="http://www.mdjs.info/" title="水东居士的茶水间，偏大数据方面" target="_blank">水东居士的茶水间，偏大数据方面</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MappedByteBuffer的一点优化</h1><div class="post-meta">Sep 27, 2017<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>最近在参考阿里的rocketMQ来优化我们自己的mq，发现一段有意思的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MappedFile.java</span><br><span class="line"></span><br><span class="line">public AppendMessageResult appendMessage(final MessageExtBrokerInner msg, final AppendMessageCallback cb) &#123;</span><br><span class="line">	/**</span><br><span class="line">	* 奇怪的地方在这里</span><br><span class="line">	/*</span><br><span class="line">    ByteBuffer byteBuffer = writeBuffer != null ? writeBuffer.slice() : this.mappedByteBuffer.slice();</span><br><span class="line">    byteBuffer.position(currentPos);</span><br><span class="line">    AppendMessageResult result =</span><br><span class="line">            cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, msg);</span><br><span class="line">    this.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">    this.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网上一搜就会搜出来对rocket的源码分析，<a href="https://github.com/YunaiV/Blog/blob/master/RocketMQ/1004-RocketMQ%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9AMessage%E5%AD%98%E5%82%A8.md" target="_blank" rel="noopener">例如</a>,他们都会分析rocketMQ的源码，<strong>但是没有给出为什么？</strong></p>
<h4 id="RocketMQ的MappedFile"><a href="#RocketMQ的MappedFile" class="headerlink" title="RocketMQ的MappedFile"></a>RocketMQ的MappedFile</h4><table>
<thead>
<tr>
<th>方式</th>
<th>写入</th>
<th>落盘</th>
</tr>
</thead>
<tbody>
<tr>
<td>方式一</td>
<td>写入内存字节缓冲区，direct类型(writeBuffer)</td>
<td>从内存字节缓冲区(write buffer)提交(commit)到文件通道(fileChannel),fileChannel flush到磁盘</td>
</tr>
<tr>
<td>方式二</td>
<td>写入映射文件字节缓冲区(mappedByteBuffer)</td>
<td>mappedByteBuffer force到磁盘</td>
</tr>
</tbody>
</table>
<p>有意思的是方式一：数据写入到mmap出来的mappedByteBuffer，而是写到一个DirectBuffer里面，然后commit到fileChannel里面，再由fileChannel刷盘。why？随便一搜mappedByteBuffer的资料都是说mmap之后速度有多快，那为什么还要多了方式一这条路？</p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>除了上面提到的问题之外，还有其他疑问：</p>
<ol>
<li>仔细看MappedFile的代码，会发现消费的时候，依然读的mappedByteBuffer，难道fileChannel write之后mappedByteBuffer会马上看到？</li>
<li>在使用mmap的同时，又使用directBuffer来写数据，liux怎么管理两份内存的？</li>
<li>这样写，有什么优势？（上面的问题）</li>
</ol>
<p>下面就来慢慢的理这几个问题。</p>
<h3 id="问题一：MappedByteBuffer和FileChannel关系"><a href="#问题一：MappedByteBuffer和FileChannel关系" class="headerlink" title="问题一：MappedByteBuffer和FileChannel关系"></a>问题一：MappedByteBuffer和FileChannel关系</h3><p>简单点说，MappedByteBuffer通过FileChannel <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode,%20long,%20long" target="_blank" rel="noopener">mmap</a>)出来之后, 两者就没有太大关系了，官方文档是这么说的：</p>
<blockquote>
<p>A mapping, once established, is not dependent upon the file channel that was used to create it. Closing the channel, in particular, has no effect upon the validity of the mapping.</p>
</blockquote>
<p>还有：</p>
<blockquote>
<p>This method is only guaranteed to force changes that were made to this channel’s file via the methods defined in this class. It may or may not force changes that were made by modifying the content of a mapped byte buffer obtained by invoking the map method. Invoking the force method of the mapped byte buffer will force changes made to the buffer’s content to be written.</p>
</blockquote>
<p>简单点说，mmap之后，MappedByteBuffer访问的是一块内存，跟原来的文件之间的同步是不确定的，这就需要看底层的os是什么时候刷新数据和请求数据了。RocketMQ里面，需要控制read的位点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @return The max position which have valid data</span><br><span class="line"> */</span><br><span class="line">    </span><br><span class="line">public int getReadPosition() &#123;</span><br><span class="line">        return this.writeBuffer == null ? this.wrotePosition.get() : this.committedPosition.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，获取数据的时候，如果使用了directBuffer，那么，读的位店依赖于commit的位点，只有directBuffer的内存被commit之后，才会被消费。</p>
<h3 id="问题二：内存管理"><a href="#问题二：内存管理" class="headerlink" title="问题二：内存管理"></a>问题二：内存管理</h3><p>这是个很深的坑，我这里简单总结下。</p>
<h4 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h4><p>想更深入的了解MappedByteBuffer，需要查一些linux的内存机制，这些资料很多，我找了一个还不错的:</p>
<ul>
<li><a href="http://duartes.org/gustavo/blog/post/page-cache-the-affair-between-memory-and-files/" target="_blank" rel="noopener">Page Cache, the Affair Between Memory and Files</a></li>
</ul>
<p>操作系统会那一部分当作page cache来用，以加速对文件的访问，因为不需要在内核空间和用户空间复制了。我们的程序，本质上都是从文件加载过来的（当然，可以通过网络channel），例如，我们可以通过 pmap 查看我们的程序内存有哪些占用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$pmap -x 32024</span><br><span class="line">32024:   *****</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode   Mapping</span><br><span class="line">0000000000400000       4       4       0 r-x--  java</span><br><span class="line">0000000000600000       4       4       4 rw---  java</span><br><span class="line">0000000000feb000    3132    3080    3080 rw---    [ anon ]</span><br><span class="line">00000006b0000000 5505024 1935360 1935360 rw---    [ anon ]</span><br><span class="line">0000003fc3200000     128     116       0 r-x--  ld-2.12.so</span><br><span class="line">0000003fc341f000       4       4       4 r----  ld-2.12.so</span><br><span class="line">0000003fc3420000       4       4       4 rw---  ld-2.12.so</span><br><span class="line">0000003fc3421000       4       4       4 rw---    [ anon ]</span><br><span class="line">0000003fc3600000    1576     672       0 r-x--  libc-2.12.so</span><br><span class="line">0000003fc378a000    2048       0       0 -----  libc-2.12.so</span><br><span class="line">0000003fc398a000      16      16       8 r----  libc-2.12.so</span><br><span class="line">0000003fc398e000       4       4       4 rw---  libc-2.12.so</span><br><span class="line">0000003fc398f000      20      20      20 rw---    [ anon ]</span><br><span class="line">0000003fc3a00000       8       8       0 r-x--  libdl-2.12.so</span><br><span class="line">0000003fc3a02000    2048       0       0 -----  libdl-2.12.so</span><br><span class="line">0000003fc3c02000       4       4       4 r----  libdl-2.12.so</span><br><span class="line">0000003fc3c03000       4       4       4 rw---  libdl-2.12.so</span><br><span class="line">0000003fc3e00000      92      72       0 r-x--  libpthread-2.12.so</span><br><span class="line">0000003fc3e17000    2048       0       0 -----  libpthread-2.12.so</span><br><span class="line">0000003fc4017000       4       4       4 r----  libpthread-2.12.so</span><br><span class="line">0000003fc4018000       4       4       4 rw---  libpthread-2.12.so</span><br><span class="line">0000003fc4019000      16       4       4 rw---    [ anon ]</span><br><span class="line">0000003fc4600000      28      20       0 r-x--  librt-2.12.so</span><br><span class="line">0000003fc4607000    2044       0       0 -----  librt-2.12.so</span><br><span class="line">0000003fc4806000       4       4       4 r----  librt-2.12.so</span><br><span class="line">0000003fc4807000       4       4       4 rw---  librt-2.12.so</span><br><span class="line">0000003fc4a00000     524      20       0 r-x--  libm-2.12.so</span><br><span class="line">0000003fc4a83000    2044       0       0 -----  libm-2.12.so</span><br><span class="line">0000003fc4c82000       4       4       4 r----  libm-2.12.so</span><br><span class="line">0000003fc4c83000       4       4       4 rw---  libm-2.12.so</span><br><span class="line">0000003fc6e00000      88      16       0 r-x--  libgcc_s-4.4.7-20120601.so.1</span><br><span class="line">0000003fc6e16000    2044       0       0 -----  libgcc_s-4.4.7-20120601.so.1</span><br><span class="line">0000003fc7015000       4       4       4 rw---  libgcc_s-4.4.7-20120601.so.1</span><br><span class="line">00007f9de5758000      12       0       0 -----    [ anon ]</span><br><span class="line">00007f9de575b000    1016      96      96 rw---    [ anon ]</span><br><span class="line">00007f9de5859000      12       0       0 -----    [ anon ]</span><br><span class="line">00007f9de585c000    1016     100     100 rw---    [ anon ]</span><br></pre></td></tr></table></figure>
<p>也可以通过proc文件下查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/5791/smaps</span><br><span class="line"></span><br><span class="line">7ec2df680000-7ec31f680000 rw-s 00000000 08:10 43779827                   /data1/vdianmq/store/message/000001977832439808</span><br><span class="line">0</span><br><span class="line">Size:            1048576 kB</span><br><span class="line">Rss:               16368 kB</span><br><span class="line">Pss:               16368 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:     16368 kB</span><br><span class="line">Private_Dirty:         0 kB</span><br><span class="line">Referenced:        16368 kB</span><br><span class="line">Anonymous:             0 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">KernelPageSize:        4 kB</span><br><span class="line">MMUPageSize:           4 kB</span><br></pre></td></tr></table></figure>
<p>可以看见基本有两类:一是带文件句柄的，另一类是［anon］的；第一类就是mmap了一个文件的，另一类就是通过程序自己申请，比如，new了一个块directBuffer，也就是后方没有文件支撑的。这两类的细节就不说来，刚兴趣可以搜一下[linux swapness]这个参数的资料，就会涉及到这个话题。</p>
<p>总的说了，通过mmap得到的MappedByteBuffer，会作为page cache的一部分来用（这一点很重要，后面还会讲）。</p>
<p>通过触发page fault来读取文件，细分又有：minor page fault和 major page fault。<a href="http://blog.scoutapp.com/articles/2015/04/10/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry" target="_blank" rel="noopener">资料</a>. 可以通过sar来查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sar -B 1</span><br><span class="line">06:02:45 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff</span><br><span class="line">06:02:46 PM    768.32   7409.90   2726.73      7.92   6984.16      0.00      0.00      0.00      0.00</span><br><span class="line">06:02:47 PM      0.00   8561.62   2953.54      0.00   7978.79      0.00      0.00      0.00      0.00</span><br><span class="line">06:02:48 PM    510.20   8102.04   2904.08      4.08   7959.18      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>
<p>除了主动刷回外，底层的操作系统也会定期刷到文件里面，可以通过调节下面的参数来调整：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;vm.min_free_kbytes=5000000&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &apos;vm.dirty_background_ratio=50&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &apos;vm.dirty_ratio=50&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &apos;vm.dirty_writeback_centisecs=360000&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &apos;vm.swappiness=10&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<h4 id="FileChannel和DirectBuffer"><a href="#FileChannel和DirectBuffer" class="headerlink" title="FileChannel和DirectBuffer"></a>FileChannel和DirectBuffer</h4><p>Java nio肯定比Java io要快，主要因为java nio是基于block的传输，将数据聚合（cache）成block再写到磁盘（或者读取），速度自然比基于字节的流要快。</p>
<p>采用DirectBuffer之后，通过Java写文件效率会高一些. </p>
<p><img src="/images/middleware/mmap-01.png" alt=""></p>
<p>因为Java GC的缘故，当我们通过FileChannel写文件的时候，如果不是使用DirectBuffer，Java会开辟一个DirectBuffer来缓存数据，以防止GC造成的数据移动。下面是Java的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sun.nio.ch.IOUtil.write</span><br><span class="line"></span><br><span class="line">static int write(FileDescriptor fd, ByteBuffer src, long position,</span><br><span class="line">                     NativeDispatcher nd)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        if (src instanceof DirectBuffer)</span><br><span class="line">            return writeFromNativeBuffer(fd, src, position, nd);</span><br><span class="line"></span><br><span class="line">        // Substitute a native buffer</span><br><span class="line">        int pos = src.position();</span><br><span class="line">        int lim = src.limit();</span><br><span class="line">        assert (pos &lt;= lim);</span><br><span class="line">        int rem = (pos &lt;= lim ? lim - pos : 0);</span><br><span class="line">        ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);</span><br><span class="line">        try &#123;</span><br><span class="line">            bb.put(src);</span><br><span class="line">            bb.flip();</span><br><span class="line">            // Do not update src until we see how many bytes were written</span><br><span class="line">            src.position(pos);</span><br><span class="line"></span><br><span class="line">            int n = writeFromNativeBuffer(fd, bb, position, nd);</span><br><span class="line">            if (n &gt; 0) &#123;</span><br><span class="line">                // now update src</span><br><span class="line">                src.position(pos + n);</span><br><span class="line">            &#125;</span><br><span class="line">            return n;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(bb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看来，使用DirectBuffer确实有好处，那么，使用了DirectBuffer之后，写文件操作的后续流程是怎么样的呢？</p>
<p><img src="/images/middleware/mmap-02.png" alt=""></p>
<p>（网上扒了一个图）</p>
<p>后续还是很麻烦：我们依然要经过linux的page cache，然后，才sync到磁盘。我们使用了DirectBuffer，只是避免了JVM 堆内存的一次拷贝，其他的流程被没有省。更多的细节可以去深入了解下page cache。</p>
<p>还有必要提的一点是，数据到了page cache，那什么时候写到disk呢？大概有三种方式：</p>
<ul>
<li>no write</li>
<li>write through</li>
<li>write back：linux的机制，对我们影响最大，我们要定期sync到磁盘</li>
</ul>
<p>详情可以查看<a href="http://sylab-srv.cs.fiu.edu/lib/exe/fetch.php?media=paperclub:lkd3ch16.pdf" target="_blank" rel="noopener">这篇论文</a></p>
<h3 id="串起来"><a href="#串起来" class="headerlink" title="串起来"></a>串起来</h3><p>将上面的内容串起来：</p>
<ol>
<li>FileChannel的写入和MapperByteBuffer的写入只能有一个在起作用。原因是他们各自为政，各自只能刷新自己的内容</li>
<li>mmap出来的MapperByteBuffer会作为page cache的一部分</li>
<li>FileChannel结合DirectBuffer会提高写入性能，避免了堆内存的一次拷贝</li>
<li>FileChannel写DirectBuffer之后，数据就到了PageCache里面，或者自己sync，或者依赖操作系统的刷新策略</li>
<li>FileChannel写DirectBuffer之后，数据就到了PageCache里面，就到了MapperByteBuffer里面，因为MapperByteBuffer被用作了文件的cache</li>
</ol>
<p>关于第5点，我们可以验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(7 * 1024);</span><br><span class="line">byteBuffer.put(data);</span><br><span class="line">mappedByteBuffer.put(data);</span><br><span class="line">sleepForAWhile();</span><br><span class="line">mappedByteBuffer.force();</span><br><span class="line">sleepForAWhile();</span><br><span class="line">fileChannel.write(byteBuffer);</span><br></pre></td></tr></table></figure>
<p>先写mappedByteBuffer，然后将数据刷新到磁盘，这个时候通过 <strong>pmap</strong>查看进程的内存:</p>
<blockquote>
<p>00007fd4e8600000   10240       4       0 rw-s-  /tmp/1</p>
</blockquote>
<p>刚开始，进程所占的文件的cache里面，dirty为0，然后，fileChannel写入后，dirty发生了变化:</p>
<blockquote>
<p>00007fd4e8600000   10240       4       4 rw-s-  /tmp/1</p>
</blockquote>
<p>验证了我们的流程：directBuffer被写入到了MapperByteBuffer（本质是，用户空间的数据，被写到了系统的page cache里面）。</p>
<p>下面是整个流程：</p>
<p><img src="/images/middleware/mmap-03.png" alt=""></p>
<p>根据这个流程回过去验证rocketMQ的代码，基本都可以验证通过，除了一点，这个流程好在哪儿？</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>rocketMQ的使用这个流程就意味着，FileChannel＋DirectBuffer的组合比MapperByteBuffer要好，但是，我搜了一堆资料，都没有明显的说明，除了在<a href="https://en.wikipedia.org/wiki/Memory-mapped_file" target="_blank" rel="noopener">wiki</a>看到了这么一句：</p>
<blockquote>
<p>The memory-mapped approach has its cost in minor page faults—when a block of data is loaded in page cache, but is not yet mapped into the process’s virtual memory space</p>
</blockquote>
<p>关于Page Fault的资料可以去搜一下。wiki里面提到的一点就是，MapperByteBuffer有一个缺点就是minor page fault的代价。但是，根据我们上面的分析，会发现，整个流程也一样会触发 page fault：因为也会写入到 page fault。不过RocketMQ做了一层优化就是 批量commit，每次累计一组page之后才commit一次: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected boolean isAbleToCommit(final int commitLeastPages) &#123;</span><br><span class="line">	int flush = this.committedPosition.get();</span><br><span class="line">	int write = this.wrotePosition.get();</span><br><span class="line">	</span><br><span class="line">	if (this.isFull()) &#123;</span><br><span class="line">	    return true;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if (commitLeastPages &gt; 0) &#123;</span><br><span class="line">	    return ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return write &gt; flush;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>能从代码看出来的优势就这么点了。另外，具体就要压测看看效果了，因为，wiki里面还提到了：</p>
<blockquote>
<p>In some circumstances, memory mapped file I/O can be substantially slower than standard file I/O. <a href="https://lists.freebsd.org/pipermail/freebsd-questions/2004-June/050371.html" target="_blank" rel="noopener">资料</a></p>
</blockquote>
<p>然后，反过来看这次问题的查找，关键在于理清楚Java FileChannel和Linux PageCache的关系，网上大部分资料都是将两个分开讲，没有像RocketMQ这样，合起来用，看来RocketMQ的性能优化已经到了很细致的地步了。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://lishoubo.github.io/2017/09/27/MappedByteBuffer的一点优化/" data-id="cjjmld0qo0009knzvlkm17mj8" class="article-share-link">分享到</a><div class="tags"><a href="/tags/性能/">性能</a><a href="/tags/文件/">文件</a><a href="/tags/PageCache/">PageCache</a></div><div class="post-nav"><a href="/2017/10/23/两阶段加锁/" class="pre">两阶段加锁</a><a href="/2017/09/21/读书-银河帝国基地七部曲/" class="next">读书-银河帝国基地七部曲</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© 如果，我有能力，可以让时间倒流。。。 </div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>