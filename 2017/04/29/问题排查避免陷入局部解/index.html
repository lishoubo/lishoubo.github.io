<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="中间件, 高可用, 架构, 读书"><title>问题排查避免陷入局部解 | Lost</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?5c504f7ca80d4d57db5434656761512d";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">问题排查避免陷入局部解</h1><a id="logo" href="/.">Lost</a><p class="description">朽骨暗夜，侯多时，你已徘徊多远?</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/favorite/"><i class="fa fa-star"> 收藏</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://lishoubo.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/中间件/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/思考/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能/">性能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统/">系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/问题排查/" style="font-size: 15px;">问题排查</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/科幻/" style="font-size: 15px;">科幻</a> <a href="/tags/心理/" style="font-size: 15px;">心理</a> <a href="/tags/一般/" style="font-size: 15px;">一般</a> <a href="/tags/推荐/" style="font-size: 15px;">推荐</a> <a href="/tags/小说/" style="font-size: 15px;">小说</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/09/读书-第三种黑猩猩/">读书-第三种黑猩猩</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/06/性能优化-偏向锁/">性能优化-偏向锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/04/性能分析工具TProfiler/">性能分析工具TProfiler</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/04/高并发统计qps/">高并发统计qps</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/读书－人人都有妄想症/">读书－人人都有妄想症</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/读书－圣经故事－以色列系列/">读书－圣经故事－以色列系列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/问题排查线程导致oom/">问题排查线程导致oom</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/问题排查RT拉长/">问题排查RT拉长</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/读书-草原动物园/">读书-草原动物园</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/07/读书-千亿之夜－百亿之昼/">读书-千亿之夜－百亿之昼</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 链接</i></div><ul></ul><a href="http://jm.taobao.org" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">问题排查避免陷入局部解</h1><div class="post-meta">Apr 29, 2017<span> | </span><span class="category"><a href="/categories/思考/">思考</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>（这篇文章早就想写了，但苦于一直忙项目开发，就拖到了现在）</p>
<p>最近有两个case对我影响比较深，</p>
<h4 id="一个case"><a href="#一个case" class="headerlink" title="一个case"></a>一个case</h4><p>一个是帮公司某个业务排查dubbo的问题， 现象是：业务发现他们调用某一个服务的时候，总是调用不到想要的版本：比如，他们本来想调用服务A的1.0版本，但实际上总是掉到2.0版本。</p>
<p>拿到问题后，我就开始梳理dubbo的代码，以及查看zk上的数据。 发现，服务A一个奇怪的名字：A2，按理说应该是服务A名字自然是A啊？继续看dubbo的代码，发现如果dubbo服务如果有两个的名字一样的话，就会依赖spring的bean的命名机制，给另一个服务命名为A2，A3等（序号自增）。</p>
<p>然后，我去查看业务的代码，发现确实他们定义了两个服务名一样的bean，只是版本不一样。我又查看了dubbo处理服务提供方的代码，发现dubbo在获取invoker的时候有这样的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) throws RemotingException&#123;</div><div class="line">		 //......忽略</div><div class="line">        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));</div><div class="line"></div><div class="line">        DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</div><div class="line">        </div><div class="line">        if (exporter == null)</div><div class="line">            throw new RemotingException(channel, &quot;Not found exported service: &quot; + serviceKey + &quot; in &quot; + exporterMap.keySet() + &quot;, may be version or group mismatch &quot; + &quot;, channel: consumer: &quot; + channel.getRemoteAddress() + &quot; --&gt; provider: &quot; + channel.getLocalAddress() + &quot;, message:&quot; + inv);</div><div class="line"></div><div class="line">        return exporter.getInvoker();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    protected static String serviceKey(int port, String serviceName, String serviceVersion, String serviceGroup) &#123;</div><div class="line">		return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>发现dubbo再获取invoker的时候，会根据serviceKey从exporterMap拿到具体的invoker，而serviceKey是通过serviceName等信息构造的。</p>
<p>OK了，看到这，我就跟业务说了我的结论：</p>
<ul>
<li>服务名字后面有个2是因为spring bean的命名机制导致的</li>
<li>dubbo对同一个服务多个版本不支持，因为serverName一样的话，会在exporterMap里面被覆盖，这样，本来是想调用版本为1的服务，结果路由到provider的时候，找到的却是版本为2的服务（因为版本为2的服务把版本1给覆盖了）</li>
</ul>
<p>因为当时在开发新的项目，就把这个问题放下了。直到后面又有业务找过来，让我评估他们的服务升级方案，他们听说了我这边的结论，就问题dubbo服务升级怎么搞，我当时认真一想，发现如果dubbo不支持一个服务多个版本的话，那dubbo也太菜了。于是又花时间仔细看了下代码。</p>
<h5 id="继续排查"><a href="#继续排查" class="headerlink" title="继续排查"></a>继续排查</h5><p>梳理下dubbo从调用方发起到走到provider的逻辑，发现调用服务的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected Result doInvoke(final Invocation invocation) throws Throwable &#123;</div><div class="line">        RpcInvocation inv = (RpcInvocation) invocation;</div><div class="line">        final String methodName = RpcUtils.getMethodName(invocation);</div><div class="line">        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</div><div class="line">        inv.setAttachment(Constants.VERSION_KEY, version);</div><div class="line">        // ...省略..</div></pre></td></tr></table></figure>
<p>dubbo会把服务的类名作为path放到attachment里面，然后，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) throws RemotingException&#123;</div><div class="line">        boolean isCallBackServiceInvoke = false;</div><div class="line">        boolean isStubServiceInvoke = false;</div><div class="line">        int port = channel.getLocalAddress().getPort();</div><div class="line">        String path = inv.getAttachments().get(Constants.PATH_KEY);</div><div class="line">		 //...省略...</div><div class="line">        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));</div></pre></td></tr></table></figure>
<p>找到具体的invoker的时候，会使用这个path，虽然serviceKey的第二个参数的函数签名是serverName（这也就是我第一次排查误解的地方），但是，具体调用的时候却是传入的path，也就是服务bean的名字</p>
<p>到这里，整个链路就清楚了，dubbo是支持一个服务（interface）多个版本的，实现思路上是把实现inerface的bean的name作为URL的path记录下来，调用的时候，先根据interface筛选provider列表，然后根据path找到具体的bean</p>
<p>(PS:由于过去较长时间了，可能有出入，但这不是重点)</p>
<h4 id="又一个case"><a href="#又一个case" class="headerlink" title="又一个case"></a>又一个case</h4><p>这个case就是当时排查我们的mq server fgc的问题，<a href="/2017/03/21/netty-entry-fgc/">netty-entry-fgc</a>.</p>
<p>这个问题最开始也是给出了一个错误的结论, 误以为是内存泄漏造成的。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>上面两个case让我感触颇深，想来想去，觉的得总结一下，如何避免后面排查问题的时候又得出一个错误的结论</p>
<p>不难看出，两个case还是有共性的：</p>
<ul>
<li>出现问题</li>
<li>排查问题</li>
<li>找到一个（代码）片段，发现这个片段刚好能够解释问题的原因</li>
<li>给出结论</li>
</ul>
<p>其实，基于片段所给出的结论，类似于算法里的局部最优解，跳出来从整体看，往往发现是错误的。所以，为了跳出来，我觉得我们在排查问题的时候，<b>如果找到了基于某个片段做出的结论，这个时候，不应该停下来，而是要在整体上，把整个正常流程梳理出来。</b> 简单点说，就是，找出了你认为导致错误的问题的时候，别急，把正确的流程梳理出来看看。</p>
<p>把结论应用于上面两个case看看：</p>
<ul>
<li>case1: 如果觉得exporterMap会把serviceName相同的覆盖掉，那么，正常的服务是怎么找到的？ 这个时候，去梳理这个流程，就会发现原来dubbo处理服务名称的时候，已经做了处理来支持多版本</li>
<li>case2: 如果觉得是内存泄漏，那么，正常的内存时候是什么时候呢？看代码，就会发现，如果entry被释放，就没有内存堆积了，就不会得出上层内存泄漏的结论了</li>
</ul>
<h5 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h5><p>case1的原因，后面经过排查，发现是业务用了一个错误的dubbo版本，这个dubbo是公司另外一个团队维护的，他们引入了一个bug，导致寻找服务时会发生版本错乱..</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://lishoubo.github.io/2017/04/29/问题排查避免陷入局部解/" data-id="cj4wss6j60011ar3k35h91hhd" class="article-share-link">分享到</a><div class="tags"><a href="/tags/问题排查/">问题排查</a></div><div class="post-nav"><a href="/2017/05/05/注意虚拟机时间漂移/" class="pre">注意虚拟机时间漂移</a><a href="/2017/04/28/架构-画几张架构图/" class="next">架构-画几张架构图</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© 如果，我有能力，可以让时间倒流。。。 </div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>